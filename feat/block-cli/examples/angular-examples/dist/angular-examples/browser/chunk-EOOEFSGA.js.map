{"version":3,"sources":["node_modules/@siemens/ix/dist/esm/find-element-CFRrPFxi.js"],"sourcesContent":["/*\n * SPDX-FileCopyrightText: 2024 Siemens AG\n *\n * SPDX-License-Identifier: MIT\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n/**\n * Will try to resolve the selector in the light dom, shadow dom or slot\n * @param selector The selector to resolve\n * @param hostElement The element to start the search from\n * @returns Promise with the resolved elements or undefined if not found\n */\nasync function resolveSelector(selector, hostElement) {\n  const elements = Array.from(document.querySelectorAll(selector));\n  if (elements.length > 0) {\n    return Promise.resolve(elements);\n  }\n  if (hostElement === undefined) {\n    return Promise.resolve(undefined);\n  }\n  const shadowRoot = getRootFor(hostElement);\n  if (shadowRoot === undefined || !(shadowRoot instanceof ShadowRoot)) {\n    return Promise.resolve(undefined);\n  }\n  const elementsInShadowRoot = Array.from(shadowRoot.querySelectorAll(selector));\n  const elementsInHost = Array.from(shadowRoot.host.querySelectorAll(selector));\n  const elementsInComponent = [...elementsInHost, ...elementsInShadowRoot];\n  if (elementsInComponent.length > 0) {\n    return Promise.resolve(elementsInComponent);\n  }\n  return Promise.resolve(undefined);\n}\n/**\n * Walk up the DOM to find the nearest shadow root\n * @param element The element to get the root for\n * @param parent This will determine how far up the DOM to travel to find the root\n * @returns The root element\n */\nfunction getRootFor(element, parent = document.body) {\n  if (!element.parentElement && !element.parentNode) {\n    return undefined;\n  }\n  if (element.parentNode instanceof ShadowRoot) {\n    return element.parentNode;\n  }\n  let currentNode = element.parentElement;\n  while (currentNode) {\n    if (currentNode.shadowRoot) {\n      return currentNode.shadowRoot;\n    } else if (currentNode.parentNode instanceof ShadowRoot) {\n      return currentNode.parentNode;\n    }\n    currentNode = currentNode.parentElement;\n  }\n  return parent;\n}\nfunction waitForSelector(selector, node = document, hostElement) {\n  return new Promise(resolve => {\n    const waitForElements = () => {\n      resolveSelector(selector, hostElement).then(elements => {\n        if (elements && elements.length > 0) {\n          resolve(elements[0]);\n          observer === null || observer === void 0 ? void 0 : observer.disconnect();\n        }\n      });\n    };\n    waitForElements();\n    const observer = new MutationObserver(() => {\n      waitForElements();\n    });\n    observer.observe(node.body, {\n      childList: true,\n      subtree: true\n    });\n  });\n}\n/**\n * Find an element by ID or reference\n * @param element The element to find\n * @param hostElement The element to start the search from\n * @returns A promise that will resolve to the element\n */\nfunction findElement(element, hostElement) {\n  if (element instanceof Promise) {\n    return element;\n  }\n  if (typeof element === 'object') {\n    return Promise.resolve(element);\n  }\n  const selector = `#${element}`;\n  return waitForSelector(selector, document, hostElement);\n}\nexport { findElement as f, resolveSelector as r };\n\n\n"],"mappings":"wCAcA,SAAeA,EAAgBC,EAAUC,EAAa,QAAAC,EAAA,sBACpD,IAAMC,EAAW,MAAM,KAAK,SAAS,iBAAiBH,CAAQ,CAAC,EAC/D,GAAIG,EAAS,OAAS,EACpB,OAAO,QAAQ,QAAQA,CAAQ,EAEjC,GAAIF,IAAgB,OAClB,OAAO,QAAQ,QAAQ,MAAS,EAElC,IAAMG,EAAaC,EAAWJ,CAAW,EACzC,GAAIG,IAAe,QAAa,EAAEA,aAAsB,YACtD,OAAO,QAAQ,QAAQ,MAAS,EAElC,IAAME,EAAuB,MAAM,KAAKF,EAAW,iBAAiBJ,CAAQ,CAAC,EAEvEO,EAAsB,CAAC,GADN,MAAM,KAAKH,EAAW,KAAK,iBAAiBJ,CAAQ,CAAC,EAC5B,GAAGM,CAAoB,EACvE,OAAIC,EAAoB,OAAS,EACxB,QAAQ,QAAQA,CAAmB,EAErC,QAAQ,QAAQ,MAAS,CAClC,GAOA,SAASF,EAAWG,EAASC,EAAS,SAAS,KAAM,CACnD,GAAI,CAACD,EAAQ,eAAiB,CAACA,EAAQ,WACrC,OAEF,GAAIA,EAAQ,sBAAsB,WAChC,OAAOA,EAAQ,WAEjB,IAAIE,EAAcF,EAAQ,cAC1B,KAAOE,GAAa,CAClB,GAAIA,EAAY,WACd,OAAOA,EAAY,WACd,GAAIA,EAAY,sBAAsB,WAC3C,OAAOA,EAAY,WAErBA,EAAcA,EAAY,aAC5B,CACA,OAAOD,CACT,CACA,SAASE,EAAgBX,EAAUY,EAAO,SAAUX,EAAa,CAC/D,OAAO,IAAI,QAAQY,GAAW,CAC5B,IAAMC,EAAkB,IAAM,CAC5Bf,EAAgBC,EAAUC,CAAW,EAAE,KAAKE,GAAY,CAClDA,GAAYA,EAAS,OAAS,IAChCU,EAAQV,EAAS,CAAC,CAAC,EACiCY,GAAS,WAAW,EAE5E,CAAC,CACH,EACAD,EAAgB,EAChB,IAAMC,EAAW,IAAI,iBAAiB,IAAM,CAC1CD,EAAgB,CAClB,CAAC,EACDC,EAAS,QAAQH,EAAK,KAAM,CAC1B,UAAW,GACX,QAAS,EACX,CAAC,CACH,CAAC,CACH,CAOA,SAASI,EAAYR,EAASP,EAAa,CACzC,GAAIO,aAAmB,QACrB,OAAOA,EAET,GAAI,OAAOA,GAAY,SACrB,OAAO,QAAQ,QAAQA,CAAO,EAEhC,IAAMR,EAAW,IAAIQ,CAAO,GAC5B,OAAOG,EAAgBX,EAAU,SAAUC,CAAW,CACxD","names":["resolveSelector","selector","hostElement","__async","elements","shadowRoot","getRootFor","elementsInShadowRoot","elementsInComponent","element","parent","currentNode","waitForSelector","node","resolve","waitForElements","observer","findElement"],"x_google_ignoreList":[0]}