/*
 * SPDX-FileCopyrightText: 2026 Siemens AG
 *
 * SPDX-License-Identifier: MIT
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
import fs from 'fs-extra';
import path from 'node:path';
import { resolveTestIds } from './utils';
import { excludedTestIds } from '../tests/exclude-test-ids';
import test from 'node:test';

const __dirname = path.dirname(new URL(import.meta.url).pathname);
const __generatedTestsPath = path.join(__dirname, '..', 'tests', 'generated');

async function main() {
  const testIds = await resolveTestIds();

  const rawTestIdsArray = `export const testIds = ${JSON.stringify(
    testIds,
    null,
    2
  )} as const;`;

  await fs.remove(__generatedTestsPath);
  await fs.ensureDir(__generatedTestsPath);

  await fs.writeFile(
    path.join(__generatedTestsPath, 'test-ids.autogenerated.ts'),
    rawTestIdsArray,
    'utf-8'
  );
  await generateAllTests();
  await generateIndexForGeneratedSnapshotTests();
  await generateIndexForGeneratedAxeTests();
}

async function generateIndexForGeneratedSnapshotTests() {
  const files = await fs.readdir(__generatedTestsPath);

  const importStatements = files
    .filter((file) => file.endsWith('.spec.ts'))
    .map((file, index) => `import './${file}';`)
    .join('\n');

  const indexPath = path.join(__generatedTestsPath, 'index.ts');
  await fs.writeFile(indexPath, importStatements, 'utf-8');
}

async function generateIndexForGeneratedAxeTests() {
  const files = await fs.readdir(__generatedTestsPath);

  const importStatements = files
    .filter((file) => file.endsWith('-axe.spec.ts'))
    .map((file, index) => `import './${file}';`)
    .join('\n');

  const indexPath = path.join(__generatedTestsPath, 'axe.ts');
  await fs.writeFile(indexPath, importStatements, 'utf-8');
}

async function generateTestForTestId(testId: string) {
  const testContent = `/*
 * SPDX-FileCopyrightText: 2025 Siemens AG
 *
 * SPDX-License-Identifier: MIT
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
import { test, expect } from '@playwright/test';
import { waitForReadiness } from '../utils';

test('${testId}', async ({ page }) => {
  await page.goto('/preview/${testId}');

  // Ugly and not the reliable way to wait for Stencil to be ready
  await waitForReadiness(page);

  await expect(page.locator('body')).toMatchAriaSnapshot({
    name: '${testId}.aria-snapshot.yaml',
  });
});
`;

  const axeTextContent = `/*
 * SPDX-FileCopyrightText: 2025 Siemens AG
 *
 * SPDX-License-Identifier: MIT
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
import { test, expect } from '@playwright/test';
import { waitForReadiness } from '../utils';
import AxeBuilder from '@axe-core/playwright';

test('${testId} - accessibility check', async ({ page }) => {
  await page.goto('/preview/${testId}');

  // Ugly and not the reliable way to wait for Stencil to be ready
  await waitForReadiness(page);

  const accessibilityScanResults = await new AxeBuilder({ page } as any).disableRules(['page-has-heading-one']).analyze();

  expect(accessibilityScanResults.violations).toEqual([]);
});
`;

  await fs.writeFile(getSnapshotTestPath(testId), testContent, 'utf-8');
  await fs.writeFile(getAxeTestPath(testId), axeTextContent, 'utf-8');
}

function getSnapshotTestPath(testId: string) {
  return path.join(__generatedTestsPath, `${testId}.spec.ts`);
}

function getAxeTestPath(testId: string) {
  return path.join(__generatedTestsPath, `${testId}-axe.spec.ts`);
}

async function generateAllTests() {
  const testIds = await resolveTestIds();

  for (const testId of testIds) {
    if (
      (excludedTestIds as any).includes(testId) ||
      testId.includes('echarts')
    ) {
      continue;
    }

    if (fs.existsSync(getSnapshotTestPath(testId))) {
      if (!process.env.CI) {
        console.log(`Test for ${testId} already exists, skipping generation.`);
      }
      continue;
    }
    await generateTestForTestId(testId);
  }
}

main().catch((err) => {
  console.error('Error in main execution:', err);
  process.exit(1);
});
