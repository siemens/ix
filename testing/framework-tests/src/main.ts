/*
 * SPDX-FileCopyrightText: 2026 Siemens AG
 *
 * SPDX-License-Identifier: MIT
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
import fs from 'fs-extra';
import path from 'node:path';
import { resolveTestIds } from './utils';
import { excludedTestIds } from '../tests/exclude-test-ids';
import test from 'node:test';

const __dirname = path.dirname(new URL(import.meta.url).pathname);
const __generatedTestsPath = path.join(__dirname, '..', 'tests', 'generated');

async function main() {
  const testIds = await resolveTestIds();

  const rawTestIdsArray = `export const testIds = ${JSON.stringify(
    testIds,
    null,
    2
  )} as const;`;

  await fs.remove(__generatedTestsPath);
  await fs.ensureDir(__generatedTestsPath);

  await fs.writeFile(
    path.join(__generatedTestsPath, 'test-ids.autogenerated.ts'),
    rawTestIdsArray,
    'utf-8'
  );
  await generateAllTests();
  await generateIndexForGeneratedTests();
}

async function generateIndexForGeneratedTests() {
  const files = await fs.readdir(__generatedTestsPath);

  const importStatements = files
    .filter((file) => file.endsWith('.spec.ts'))
    .map((file, index) => `import './${file}';`)
    .join('\n');

  const indexPath = path.join(__generatedTestsPath, 'index.ts');
  await fs.writeFile(indexPath, importStatements, 'utf-8');
}

async function generateTestForTestId(testId: string) {
  const testContent = `/*
 * SPDX-FileCopyrightText: 2025 Siemens AG
 *
 * SPDX-License-Identifier: MIT
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
import { test, expect } from '@playwright/test';
import { waitForReadiness } from '../utils';
import AxeBuilder from '@axe-core/playwright';

if (process.env.DO_ACCESSIBILITY_AUDIT) {
  test('${testId} - accessibility check', async ({ page }) => {
    await page.goto('/preview/${testId}');

    // Ugly and not the reliable way to wait for Stencil to be ready
    await waitForReadiness(page);

    const accessibilityScanResults = await new AxeBuilder({ page } as any).disableRules(['page-has-heading-one']).analyze();

    expect(accessibilityScanResults.violations).toEqual([]);
  });
}

test('${testId}', async ({ page }) => {
  await page.goto('/preview/${testId}');

  // Ugly and not the reliable way to wait for Stencil to be ready
  await waitForReadiness(page);

  await expect(page.locator('body')).toMatchAriaSnapshot({
    name: '${testId}.aria-snapshot.yaml',
  });
});
`;

  const testFilePath = getTestPath(testId);
  await fs.writeFile(testFilePath, testContent, 'utf-8');
}

function getTestPath(testId: string) {
  const testFilePath = path.join(__generatedTestsPath, `${testId}.spec.ts`);
  return testFilePath;
}

async function generateAllTests() {
  const testIds = await resolveTestIds();

  for (const testId of testIds) {
    if (
      (excludedTestIds as any).includes(testId) ||
      testId.includes('echarts')
    ) {
      continue;
    }

    if (fs.existsSync(getTestPath(testId))) {
      if (!process.env.CI) {
        console.log(`Test for ${testId} already exists, skipping generation.`);
      }
      continue;
    }
    await generateTestForTestId(testId);
  }
}

main().catch((err) => {
  console.error('Error in main execution:', err);
  process.exit(1);
});
